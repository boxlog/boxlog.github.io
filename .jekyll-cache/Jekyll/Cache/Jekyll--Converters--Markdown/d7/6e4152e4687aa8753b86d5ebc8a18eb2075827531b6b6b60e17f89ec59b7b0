I"<p>테이블을 구성할 때 중요한 것 중 하나는 PK 입니다.</p>

<p>JPA는 이 PK를 객체와 매핑시켜주기 위해 애노테이션을 사용합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span> <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">stargey</span> <span class="o">=</span> <span class="nc">GeneratedType</span><span class="o">.</span><span class="na">XXX</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
</code></pre></div></div>

<p>@Id 객체를 테이블의 Id로 매핑시켜주는 애노테이션입니다.</p>

<p>여기서 중요한 것은 GeneratedValue입니다.</p>

<p>GeneratedValue는 테이블의 PK 값을 설정할 때 어떤 전략으로 사용할 것인지 묻는 역할을 합니다.</p>

<p>이 전략에는 4가지 방식이 있습니다.</p>

<hr />
<ol>
  <li>
    <p>IDENTITY</p>
  </li>
  <li>
    <p>SEQUENCE</p>
  </li>
  <li>
    <p>TABLE</p>
  </li>
  <li>
    <p>AUTO</p>
  </li>
</ol>

<hr />

<p><strong>첫번째</strong>, IDENTITY는 키 생성 방식을 DB에 전부 맡겨버립니다.</p>

<p>IDENTITY의 중요한 점은 PK의 생성 시점이 DB가 데이터를 생성하는 시점과 같다는 점입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>

<p>이전 포스팅에서 persist는 member 객체를 영속성 컨텍스트로 관리한다는 뜻이라고 말했습니다.</p>

<p>하지만 영속성 컨텍스트는 객체의 Id값이 정해져있지 않으면 영속성 컨텍스트를 만들어내지를 못합니다.</p>

<p>그래서 JPA는 원래라면 persist후에 commit() 시점에서야 DB에 INSERT 쿼리문을 내보내는게 정상이지만 IDENTITY 방식일 때는 persist와 동시에 쿼리문을 보내 PK값을 받아옵니다.</p>

<hr />

<p><strong>두번째</strong>, SEQUENCE 입니다.</p>

<p>DB 시퀀스 오브젝트를 사용하는 방식입니다. SEQUENCE라 함은 유일한 값을 생성해주는 오라클 객체입니다.</p>

<p>이 SEQUENCE 값을 이용하면 기본키와 같이 순차적으로 증가하는 컬럼의 자동 생성이 가능합니다.</p>

<p>SEQUENCE 전략은 @SequenceGenerator 라는 것이 필요로합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="nd">@SequenceGenerator</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_SEQ_GENERATOR"</span><span class="o">,</span>
        <span class="n">sequenceName</span> <span class="o">=</span> <span class="s">"MEMBER_SEQ"</span><span class="o">,</span>
        <span class="n">initialValue</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> 
        <span class="n">allocationSize</span> <span class="o">=</span> <span class="mi">50</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">SEQUENCE</span><span class="o">,</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="s">"MEMBER_SEQ_GENERATOR"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>먼저 Member라는 클래스 위에 @SequenceGenerator의 정보를 적어주고 Id의 generator의 이름과 위 설정 정보의 이름과 매칭 시켜주면 됩니다.</p>

<p>initialValue는 최초 시작하는 시퀀스의 넘버입니다.</p>

<p>allocationSize는 한 번에 불러올 sequence 값을 위한 것인데, 기본 옵션은 50으로 설정되있습니다.</p>

<p>시퀀스 전략을 사용하면 디버깅 코드에 다음과 같이 나타납니다.</p>

<pre><code class="language-debug">Hibernate: 
    call next value for MEMBER_SEQ
Hibernate: 
    /* insert com.demo.Member
        */ insert 
        into
            Member
            (username, id) 
        values
            (?, ?)
</code></pre>

<p>여기서 insert 문 이외에 call next ~~~ 문이 보이는데 JPA 입장에서 보면</p>

<p>“영속성 컨텍스트를 만들어야하니까 PK값 내놔”</p>

<p>정도가 되겠네요.</p>

<p>그런데 PK값이 필요할 때마다 call을 해서 그 때마다 영속성 컨텍스트를 만든다면 낭비일 수 밖에 없습니다.</p>

<p>50개의 PK값을 생성하려면 50번의 call을 해야하고, 숫자가 더 많아 질수록 성능이 하향 되겠죠.</p>

<p>그래서 allocationSize = 50 이라는 정보를 통해 미리 50개를 불러와버리는 겁니다.</p>

<p>이미 50개의 sequence를 불러왔으니 굳이 50번을 불러올 필요없이 추후에 51번 째 Id 값이 생길 때 다시 한번 더 불러오면 됩니다. 다음 sequence는 51번째부터 100번째까지 불러오는 것이죠.</p>

<hr />

<p><strong>세번째로,</strong> Table 전략은 Sequence 전략과 비슷하게 @TableGenerator라는 설정 정보가 필수적입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@TableGenerator</span><span class="o">(</span>
 <span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_TABLE_GENERATOR"</span><span class="o">,</span>
 <span class="n">table</span> <span class="o">=</span> <span class="s">"MY_TABLE"</span><span class="o">,</span>
 <span class="n">pkColumnValue</span> <span class="o">=</span> <span class="err">“</span><span class="no">MEMBER_SEQ</span><span class="s">", allocationSize = 50)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE,
        generator = "</span><span class="no">MEMBER_TABLE_GENERATOR</span><span class="err">"</span><span class="o">)</span>
        <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span> 
</code></pre></div></div>

<p>Sequence와 매우 비슷하게 보이지만 Table 전략은 사용자가 직접 테이블을 만들어준다는 점이 차이점입니다.</p>

<p>DB 종류에 상관없이 적용 가능하다는 장점이 있지만 아무래도 테이블을 직접 생성한다는 점에서 성능 하향의 여지가 있습니다.</p>

<hr />

<p><strong>마지막</strong> AUTO 입니다.</p>

<p>AUTO는 데이터베이스의 종류에 따라 IDENTITY, TABLE, SEQUENCE 전략을 알아서 선택해줍니다.</p>

<p>개발자가 Oracle DB를 사용하면 SEQUENCE 전략을 자동으로 선택하고 MySQL이라면 IDENTITY 전략을 선택해주신다 보시면 됩니다.</p>

:ET